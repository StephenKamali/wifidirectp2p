package hopscotch.encryption;

import javax.crypto.*;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;

import java.nio.charset.StandardCharsets;
import java.security.*;
import java.util.Arrays;
import java.util.Base64;

public class DataEncryptor {

    public static void main(String[] args) {
        //RSA-2048 example
        String myString = "Hello, my name is Kyle!";
        KeyPair myKeys = genNewRSAKeySet();
        byte[] message = convertStringToBytes(myString);
        byte[] encryptedMessage = encryptRSAMessage(myKeys.getPublic(), message);
        byte[] decryptedMessage = decryptRSAMessage(myKeys.getPrivate(), encryptedMessage);
        String decryptedString = convertBytesToString(decryptedMessage);
        System.out.println("RSA works: " + (decryptedString.equals(myString)));

        //AES-128 example
        SecretKey aesKey = genNewAESKey();
        String myPhrase = "This is great!";
        byte[] phraseBytes = convertStringToBytes(myPhrase);
        IvParameterSpec myIV = genNewIV(phraseBytes);
        byte[] encryptedPhrase = encryptAESMessage(aesKey, myIV, phraseBytes);
        byte[] decryptedPhrase = decryptAESMessage(aesKey, myIV, encryptedPhrase);
        String newPhrase = convertBytesToString(decryptedPhrase);
        System.out.println("AES Works: " + myPhrase.equals(newPhrase));

        //End-To-End Example---------------------------------------------------------

        //Requester sends out plaintext: [string search, requester public key]
        String search = "CAT MEMES LUL UWU";
        KeyPair requesterKeys = genNewRSAKeySet();
        PublicKey requesterPublic = requesterKeys.getPublic();
        //send [search, requesterPublic] values off

        /*Responder sends RSA encrypted (with requester's public key):
                          [encrypted(matching file metadata), plaintext(responder's public key)]*/
        KeyPair ResponderKeys = genNewRSAKeySet();
        String fileMetaData = "CAT MEMES LUL UWU LOOK AT HIS LIL PAW PAW";
        byte[] encryptedMeta = encryptRSAMessage(requesterKeys.getPublic(),
                convertStringToBytes(fileMetaData));
        PublicKey responderPublic = ResponderKeys.getPublic();
        //send [encryptedMeta, responderPublic] values off

        //At this point, the requester should have numerous incoming responses from various
        //responders. They should decrypt each received metadata to manually select which
        //one they would like to download.
        //for each received response:
        String responseMessage = convertBytesToString(decryptRSAMessage(
                requesterKeys.getPrivate(), encryptedMeta));

        //Requester selects which one they want and:
        /*Requester sends RSA encrypted (with responder's public key):
           [download confirmation, encrypted(metadata for file they want + new AES key + IV]*/
        Boolean download = true;
        SecretKey ourSharedKey = genNewAESKey();
        String sharedKeyString = SecretKeyToString(ourSharedKey);
        IvParameterSpec ourSharedIV = genNewIV(convertStringToBytes(responseMessage));
        String IVString = convertBytesToString(ourSharedIV.getIV());
        String combinedData = responseMessage + sharedKeyString + IVString;
        byte[] encryptedHandshake = encryptRSAMessage(responderPublic,
                convertStringToBytes(combinedData));
        //send [download, encryptedHandshake] values off

        //The responder receives the combined data, which is file metadata appended
        //to the 16-bit AES key and 16-bit IV. They will have to separate them out to utilize the key
        //and IV to encrypt the corresponding file.
        String keyString = combinedData.substring(combinedData.length() - 40, combinedData.length() - 16);
        String rebuiltIVString = combinedData.substring(combinedData.length() - 16);
        SecretKey rippedKey = StringToSecretKey(keyString);
        IvParameterSpec theIV = new IvParameterSpec(convertStringToBytes(rebuiltIVString));

        /*Responder sends AES-encrypted (key generated by Requester):
                                                [file requested]*/
        String fileContent = "Pretend this is a file. Just like this string," +
                "a file can be turned into a byte array. Don't worry.";
        byte[] encryptedFile = encryptAESMessage(rippedKey, theIV, convertStringToBytes(fileContent));
        //send [encryptedFile] values off

        //At this point, the requester receives the AES-encrypted file from the responder.
        //The requester needs to decrypt the file and the transaction is complete.
        byte[] decryptedFile = decryptAESMessage(ourSharedKey, ourSharedIV, encryptedFile);
        String rebuiltFile = convertBytesToString(decryptedFile);
        System.out.println("End-To-End works: " + rebuiltFile.equals(fileContent));

        //--------------------------------------------------------
    }

    public static KeyPair genNewRSAKeySet() {
        try {
            KeyPairGenerator newGenerator = KeyPairGenerator.getInstance("RSA");
            newGenerator.initialize(2048, new SecureRandom());
            return newGenerator.generateKeyPair();
        } catch (NoSuchAlgorithmException e) {
            System.out.println("No Such algorithm exists!");
        }
        return null;
    }

    public static byte[] encryptRSAMessage(PublicKey myPublicKey, byte[] message) {
        try {
            Cipher cipher = Cipher.getInstance("RSA");
            cipher.init(Cipher.ENCRYPT_MODE, myPublicKey, new SecureRandom());
            return cipher.doFinal(message);
        } catch (NoSuchPaddingException b) {
            System.out.println("No such padding exists!");
        } catch (NoSuchAlgorithmException e) {
            System.out.println("No Such algorithm exists!");
        } catch (InvalidKeyException i) {
            System.out.println("Invalid key provided!");
        } catch (BadPaddingException k) {
            System.out.println("Bad padding provided");
        } catch (IllegalBlockSizeException d) {
            System.out.println("Illegal block size provided!");
        }
        return null;
    }

    public static byte[] decryptRSAMessage(PrivateKey myPrivateKey, byte[] bytes) {
        try {
            Cipher cipher = Cipher.getInstance("RSA");
            cipher.init(Cipher.DECRYPT_MODE, myPrivateKey, new SecureRandom());
            return cipher.doFinal(bytes);
        } catch (NoSuchPaddingException b) {
            System.out.println("No such padding exists!");
        } catch (NoSuchAlgorithmException e) {
            System.out.println("No Such algorithm exists!");
        } catch (InvalidKeyException i) {
            System.out.println("Invalid key provided!");
        } catch (BadPaddingException k) {
            System.out.println("Bad padding provided");
        } catch (IllegalBlockSizeException d) {
            System.out.println("Illegal block size provided!");
        }
        return null;
    }

    public static byte[] convertStringToBytes(String message) {
        return message.getBytes(StandardCharsets.ISO_8859_1);
    }

    public static String convertBytesToString(byte[] bytes) {
        return new String(bytes, StandardCharsets.ISO_8859_1);
    }

    //beginning of AES functions

    public static SecretKey genNewAESKey() {
        try {
            KeyGenerator newGenerator = KeyGenerator.getInstance("AES");
            newGenerator.init(128, new SecureRandom());
            return newGenerator.generateKey();
        } catch (NoSuchAlgorithmException e) {
            System.out.println("No Such algorithm exists!");
        }
        return null;
    }

    public static byte[] encryptAESMessage(SecretKey aesKey, IvParameterSpec initialIV, byte[] message) {
        try {
            Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5Padding");
            cipher.init(Cipher.ENCRYPT_MODE, aesKey, initialIV);
            return cipher.doFinal(message);
        } catch (NoSuchPaddingException b) {
            System.out.println("No such padding exists!");
        } catch (NoSuchAlgorithmException e) {
            System.out.println("No Such algorithm exists!");
        } catch (InvalidKeyException i) {
            System.out.println("Invalid key provided!");
        } catch (BadPaddingException k) {
            System.out.println("Bad padding provided");
        } catch (IllegalBlockSizeException d) {
            System.out.println("Illegal block size provided!");
        } catch (InvalidAlgorithmParameterException l) {
            System.out.println("Invalid IV!");
        }
        return null;
    }

    public static byte[] decryptAESMessage(SecretKey aesKey, IvParameterSpec initialIV, byte[] bytes) {
        try {
            Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5Padding");
            cipher.init(Cipher.DECRYPT_MODE, aesKey, initialIV);
            return cipher.doFinal(bytes);
        } catch (NoSuchPaddingException b) {
            System.out.println("No such padding exists!");
        } catch (NoSuchAlgorithmException e) {
            System.out.println("No Such algorithm exists!");
        } catch (InvalidKeyException i) {
            System.out.println("Invalid key provided!");
        } catch (BadPaddingException k) {
            System.out.println("Bad padding provided");
        } catch (IllegalBlockSizeException d) {
            System.out.println("Illegal block size provided!");
        } catch (InvalidAlgorithmParameterException l) {
            System.out.println("Invalid IV!");
        }
        return null;
    }

    public static IvParameterSpec genNewIV(byte[] base) {
        try {
            //hash the base, take the first 16 bytes, return those as an IV
            return new IvParameterSpec(Arrays.copyOf(MessageDigest.getInstance("SHA-256").digest(base), 16));
        } catch (NoSuchAlgorithmException e) {
            System.out.println("No Such algorithm exists!");
        }
        return null;
    }

    public static String SecretKeyToString(SecretKey myKey) {
        return Base64.getEncoder().encodeToString(myKey.getEncoded());
    }

    public static SecretKey StringToSecretKey(String myString) {
        byte[] stringBytes = Base64.getDecoder().decode(myString);
        return new SecretKeySpec(stringBytes, 0, stringBytes.length, "AES");
    }
}
